<html>
	<head>
	<style>
		body {
			background-color: #2C2F33;
		}
		
		canvas {
			border: 2px solid #7289DA;
		}
	</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
	</head>
<body>
	<canvas width=600 height=600 />
</body>
<script>
	const canvas = document.getElementsByTagName("canvas")[0];
	const ctx = canvas.getContext("2d");
	const host = "localhost:3000";
	const socket = io.connect(host);
	const sessionid = (window.location.search.match(/[\?\&]sid=[^\&]{12,20}/) || [""])[0];
	let blobs = [],
	    objects = {
	    	walls: []
	    };
	
	
	canvas.width = window.innerWidth - 30;
	canvas.height = window.innerHeight - 30;
	
	// Wall structure
	class WallObj {
		constructor(x = Math.floor(Math.random() * (canvas.width - 50) + 25), y = Math.floor(Math.random() * (canvas.width - 50) + 25)) {
			this.x = x;
			this.y = y;
			this.width = 30;
			this.height = 30;
			this.img = new Image();
			this.img._ready = false;
			this.url = "../assets/brickwall.png";
		}
		
		setImage(img = this.url) {
			return new Promise((a,b) => {
				this.img.src = img;
				this.img.onload = () => a(), this.img._ready = true;
			});
		}
		
		display() {
			return new Promise((a,b) => {
				if (!this.img._ready) b("Image not loaded.");
				ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
			});
		}
	};
	
	// Blob structure
	class BlobCode {
		static get blobowo()         { return "../assets/blobowo.png";         }
		static get blobevil()        { return "../assets/blobevil.png";        }
		static get blobeyes()        { return "../assets/blobeyes.png";        }
		static get blobkittenknife() { return "../assets/BlobKittenKnife.png"; }
		static get blobpeek()        { return "../assets/blobpeek.png";        }
		static get partyblob()       { return "../assets/partyblob.gif";       }
	};
	
	class BlobObj {
		constructor(br, owner, x = window.innerWidth / 2, y = window.innerHeight / 2) {
			this.x = x;
			this.y = y;
			this.owner = owner;
			this.br = br;
			this.img = new Image();
			this._direction = 0;
		}
		
		get direction() { return this._direction; }
		
		set direction(value) { 
			socket.emit("ffaDirectionChange", Object.assign(ownBlob, {_direction: value}));
			return this._direction = value;
		}
		
		setBlob(blobimage = BlobCode.blobowo) {
			if (blobimage === BlobCode.partyblob0) blobimage = BlobCode.blobowo; 
			return new Promise((a,b) => {
				try {
					this.img.src = blobimage;
					this.img.onload = () => a(), this.img._ready = true;
				} catch(e) { b(e); }
			});
		}
		
		display(du = false, dbr = false, w = 30, h = 30) {
			return new Promise((a,b) => {
				if (!this.img._ready) b("Image not loaded.");
				ctx.drawImage(this.img, this.x, this.y, w, h);
				if (du === true) {
					ctx.font = "15px Arial";
					ctx.fillStyle = "white";
					ctx.fillText(this.owner + (dbr === true ? `(${this.br})` : ""), this.x, this.y - 10);
				}
			});
		}
		
		static display(arr, du = false, dbr = false, w = 30, h = 30) {
			if (typeof arr === "object" && arr != null) {
				if (arr.constructor.name === "Array") {
					for (const blob of arr) {
						blob.display(du, dbr, w, h);
					}
				}
			}
		}
	};
	
	
	// Display all blobs
	for (const blob of blobs) {
		blob.setBlob().then(() => blob.display(true, true));
	}
	
	// Own blob
	const ownBlob = new BlobObj();
	ownBlob.ready = false;
	ownBlob.setBlob().then(() => ownBlob.display(true, true));
	
	// Events (socket.io)
	
	
	socket.on("ffaPlayerDelete", eventd => {
		blobs.splice(blobs.findIndex(v => v.owner === eventd), 1);
	});
	socket.on("ffaLoginFailed", str => alert(str));
	socket.on("ffaPlayerUpdate", async eventd => {
		for (const player of eventd) {
			if (player.owner !== ownBlob.owner) {
				if (blobs.some(v => v.owner === player.owner)) {
					blobs[blobs.findIndex(v => v.owner === player.owner)].x = player.x;
					blobs[blobs.findIndex(v => v.owner === player.owner)].y = player.y;
					blobs[blobs.findIndex(v => v.owner === player.owner)].br = player.br;
				} else {
					const n = new BlobObj(player.br, player.owner, player.x, player.y);
					await n.setBlob();
					n.display(true, true);
					blobs.push(n);
				}
			}
		}
		blobs = blobs.filter(v => blobs.filter(vv => vv.owner === v.owner).length < 2);
	});
	socket.on("ffaObjectsHeartbeat", eventd => {
		for (let i = 0; i < eventd.walls.length; ++i) {
			const wall = new WallObj(eventd.walls[i].x, eventd.walls[i].y);
		}
	});
	socket.on("ffaHeartbeat", d => {
		ownBlob.owner = d.username;
		ownBlob.br = d.br;
		ownBlob.ready = true;
		blobs.push(ownBlob);
	});
	socket.on("ffaUnauthorized", () => document.location.href = "/login/");
	socket.emit("ffaPlayerCreate", sessionid.substr(sessionid.indexOf("=") + 1));
	
	
	// Events (Window/Document)
	window.addEventListener("resize", () => {
		canvas.width = window.innerWidth - 30;
		canvas.height = window.innerHeight - 30;
	});
	
	document.addEventListener("keydown", eventd => {
		switch (eventd.keyCode) {
			case 87: // w
			ownBlob.direction = 0;
			break;
			case 68: // d
			ownBlob.direction = 1;
			break;
			case 83: // s
			ownBlob.direction = 2;
			break;
			case 65: // a
			ownBlob.direction = 3;
			break;
			case 78:
			socket.emit("ffaNomKey");
			break;
			default:
			break;
		}
	});
	
	
	// Utilities
	function clearCanvas(context = ctx) {
		context.clearRect(0, 0, canvas.width, canvas.height);
	}
	function displayLeaderboard(context = ctx) {
		context.fillRect(canvas.width - 100, 0, 100, (blobs.length * 20) + 40);
		context.fillStyle = "black";
		context.font = "14px Arial";
		context.fillText("Leaderboard", canvas.width - 90, 15);
		context.rect(canvas.width - 100, 20, 100, .1);
		const sortedblobs = blobs.sort((a,b) => b.br > a.br);
		for(let i = 0; i < sortedblobs.length; ++i) {
			context.font = "12px Arial";
			context.fillStyle = "black";
			context.fillText(`${sortedblobs[i].owner}  ${sortedblobs[i].br} BR`, canvas.width - 90, 22 + (12 * (i + 1)));
		}
		context.stroke();
	}
	function displayWalls() {
		for (const wall of objects.walls) {
			wall.display();
		}
	}
	
	
	// Coordinate updates
	setInterval(() => {
		if (ownBlob.ready === false) return;
		if (ownBlob.x <= 23 && ownBlob.direction === 3) return clearCanvas(), BlobObj.display(blobs, true, true), displayLeaderboard();
		else if (ownBlob.y <= 23 && ownBlob.direction === 0) return clearCanvas(), BlobObj.display(blobs, true, true), displayLeaderboard();
		else if (ownBlob.y >= canvas.height - 35 && ownBlob.direction === 2) return clearCanvas(), BlobObj.display(blobs, true, true), displayLeaderboard();
		else if (ownBlob.x >= canvas.width - 35 && ownBlob.direction === 1) return clearCanvas(), BlobObj.display(blobs, true, true), displayLeaderboard();
		
		if (ownBlob.direction === 0) ownBlob.y -= 1.5;
		else if (ownBlob.direction === 1) ownBlob.x += 1.5;
		else if (ownBlob.direction === 2) ownBlob.y += 1.5;
		else if (ownBlob.direction === 3) ownBlob.x -= 1.5;
		clearCanvas();
		BlobObj.display(blobs, true, true);
		displayLeaderboard();
		socket.emit("ffaCoordinateChange", ownBlob);
	}, 1);
	
	socket.on("ffaPlayerNommed", eventd => {
		blobs[blobs.findIndex(v => v.owner === eventd.loser.owner)].br = (eventd.loser.br - eventd.result <= 0 ? 1 : eventd.loser.br - eventd.result);
		blobs[blobs.findIndex(v => v.owner === eventd.winner.owner)].br = (eventd.winner.br + eventd.result > 9999 ? 9999 : winner.br + eventd.result);
		if (eventd.loser.owner === ownBlob.owner) {
			ownBlob.x = eventd.loser.x;
			ownBlob.y = eventd.loser.y;
		}
	});
</script>
</html>
