<html>
	<head>
	<link href="https://fonts.googleapis.com/css?family=Cairo|K2D" rel="stylesheet">
	<style>
		body {
			background-color: #222;
		}
	</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
	</head>
<body>
	<canvas width=600 height=600 />
</body>
<script>
	const canvas = document.getElementsByTagName("canvas")[0];
	const ctx = canvas.getContext("2d");
	const host = "localhost:3000";
	const socket = io.connect(host);
	const sessionid = (window.location.search.match(/[\?\&]sid=[^\&]{12,20}/) || [""])[0];
	let blobs = [],
	    objects = {
	    	walls: [],
	    	images: {
				blobnom: null
			}
	    };
	var scale = 1;
	const mapSize = {
		width: 2000,
		height: 2000
	};
	
	
	canvas.width = window.innerWidth - 30;
	canvas.height = window.innerHeight - 30;
	
	// Wall structure
	class WallObj {
		constructor(x = Math.floor(Math.random() * (canvas.width - 50) + 25), y = Math.floor(Math.random() * (canvas.width - 50) + 25)) {
			this.x = x;
			this.y = y;
			this.width = 30;
			this.height = 30;
			this.img = new Image();
			this.img._ready = false;
			this.url = "../assets/brickwall.png";
		}
		
		setImage(img = this.url) {
			return new Promise((a,b) => {
				this.img.src = img;
				this.img.onload = () => a(), this.img._ready = true;
			});
		}
		
		display() {
			return new Promise((a,b) => {
				if (!this.img._ready) b("Image not loaded.");
				ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
			});
		}
	};
	
	// Blob structure
	class BlobCode {
		static get blobowo()         { return "../assets/blobowo.png";         }
		static get blobevil()        { return "../assets/blobevil.png";        }
		static get blobeyes()        { return "../assets/blobeyes.png";        }
		static get blobkittenknife() { return "../assets/BlobKittenKnife.png"; }
		static get blobpeek()        { return "../assets/blobpeek.png";        }
		static get partyblob()       { return "../assets/partyblob.gif";       }
		static get blobnom()		 { return "../assets/blobnom.png";		   }
	};
	
	class BlobObj {
		constructor(br, owner, x = window.innerWidth / 2, y = window.innerHeight / 2) {
			this.x = x;
			this.y = y;
			this.owner = owner;
			this.br = br;
			this.img = new Image();
			this._direction = 0;
			this.lastnom = 0;
		}
		
		get direction() { return this._direction; }
		
		set direction(value) { 
			socket.emit("ffaDirectionChange", Object.assign(ownBlob, {_direction: value}));
			return this._direction = value;
		}
		
		setBlob(blobimage = BlobCode.blobowo) {
			if (blobimage === BlobCode.partyblob0) blobimage = BlobCode.blobowo; 
			return new Promise((a,b) => {
				try {
					this.img.src = blobimage;
					this.img.onload = () => a(), this.img._ready = true;
				} catch(e) { b(e); }
			});
		}
		
		display(du = false, dbr = false, w = 30, h = 30) {
			return new Promise((a,b) => {
				if (!this.img._ready) b("Image not loaded.");
				const canvasX = canvas.width / 2 - w;
				const canvasY = canvas.height / 2 - h;
				if (this.owner === ownBlob.owner) {
					ctx.drawImage(this.img, canvasX, canvasY, w * scale, h * scale);
					ctx.fillText(this.owner + (dbr === true ? `(${this.br})` : ""), canvasX, (canvasY) - 10);
				} else {
					let blobCanvasX = 0, blobCanvasY = 0;
					if (ownBlob.x >= this.x) {
						blobCanvasX = (canvas.width / 2) - (ownBlob.x - this.x);
					} else if (ownBlob.x < this.x) {
						blobCanvasX = (canvas.width / 2) + (this.x - ownBlob.x);
					}
					
					if (ownBlob.y >= this.y) {
						blobCanvasY = (canvas.height / 2) - (ownBlob.y - this.y);
					} else if (ownBlob.y < this.y) {
						blobCanvasY = (canvas.height / 2) + (this.y - ownBlob.y);
					}
					
					ctx.drawImage(this.img, blobCanvasX * scale, blobCanvasY * scale, w * scale, h * scale);
					if (du === true) {
						ctx.font = (15 * scale).toString() + "px Cairo";
						ctx.fillStyle = "white";
						ctx.fillText(this.owner + (dbr === true ? `(${this.br})` : ""), blobCanvasX * scale, (blobCanvasY * scale) - 10);
					}
				}
			});
		}
		
		static display(arr, du = false, dbr = false, w = 30, h = 30) {
			if (typeof arr === "object" && arr != null) {
				if (arr.constructor.name === "Array") {
					for (const blob of arr) {
						blob.display(du, dbr, w, h);
					}
				}
			}
		}
	};
	
	
	// Display all blobs
	for (const blob of blobs) {
		blob.setBlob().then(() => blob.display(true, true));
	}
	
	// Own blob
	const ownBlob = new BlobObj();
	ownBlob.ready = false;
	ownBlob.setBlob().then(() => ownBlob.display(true, true));
	
	// Initialize blob images
	objects.images.blobnom = new Image();
	objects.images.blobnom.src = BlobCode.blobnom;
	objects.images.blobnom.onload = () => {
		objects.images.blobnom._ready = true;
	};
	
	// Events (socket.io)
	socket.on("ffaPlayerDelete", eventd => {
		blobs.splice(blobs.findIndex(v => v.owner === eventd), 1);
	});
	socket.on("ffaLoginFailed", str => alert(str));
	socket.on("ffaPlayerUpdate", async eventd => {
		for (const player of eventd) {
			if (player.owner !== ownBlob.owner) {
				if (blobs.some(v => v.owner === player.owner)) {
					blobs[blobs.findIndex(v => v.owner === player.owner)].x = player.x;
					blobs[blobs.findIndex(v => v.owner === player.owner)].y = player.y;
					blobs[blobs.findIndex(v => v.owner === player.owner)].br = player.br;
				} else {
					const n = new BlobObj(player.br, player.owner, player.x, player.y);
					await n.setBlob();
					n.display(true, true);
					blobs.push(n);
				}
			}
		}
		blobs = blobs.filter(v => blobs.filter(vv => vv.owner === v.owner).length < 2);
	});
	socket.on("ffaObjectsHeartbeat", eventd => {
		for (let i = 0; i < eventd.walls.length; ++i) {
			const wall = new WallObj(eventd.walls[i].x, eventd.walls[i].y);
		}
	});
	socket.on("ffaHeartbeat", d => {
		ownBlob.owner = d.username;
		ownBlob.br = d.br;
		ownBlob.ready = true;
		blobs.push(ownBlob);
	});
	socket.on("ffaUnauthorized", () => document.location.href = "/login/");
	socket.emit("ffaPlayerCreate", sessionid.substr(sessionid.indexOf("=") + 1));
	
	
	// Events (Window/Document)
	window.addEventListener("resize", () => {
		canvas.width = window.innerWidth - 30;
		canvas.height = window.innerHeight - 30;
	});
	
	document.addEventListener("keydown", eventd => {
		switch (eventd.keyCode) {
			case 87: // w
			ownBlob.direction = 0;
			break;
			case 68: // d
			ownBlob.direction = 1;
			break;
			case 83: // s
			ownBlob.direction = 2;
			break;
			case 65: // a
			ownBlob.direction = 3;
			break;
			case 78:
			ownBlob.lastnom = Date.now();
			socket.emit("ffaNomKey");
			break;
			default:
			break;
		}
	});
	
	const mouseScrollEvent = (...eventd) => {
		const [event] = eventd;
		if (typeof event === "undefined") event = window.event;
		var deltaValue = 0;
		if (event.wheelDelta) {
			deltaValue = event.wheelDelta / 120; 
		} else if (event.detail) {
			deltaValue = -event.detail / 3;
		}
		if (!deltaValue) return;
		
		if (deltaValue < 0 && scale > .5) scale -= .1;
		else if (scale < 7) scale += .1;
	};
	
	if (window.addEventListener) {
		window.addEventListener("DOMMouseScroll", mouseScrollEvent);
	}
	window.onmousewheel = document.onmousewheel = mouseScrollEvent;
	
	
	// Utilities
	function displayUI(excludes = []) {
		if (!excludes.includes("clearCanvas")) clearCanvas();
		if (!excludes.includes("drawBorder")) drawBorder();
		if (!excludes.includes("BlobObjDisplay")) BlobObj.display(blobs, true, true);
		if (!excludes.includes("displayLeaderboard")) displayLeaderboard();
		if (!excludes.includes("displayCooldown")) displayCooldown();
		if (!excludes.includes("displayPlayerStats")) displayPlayerStats();
	}
	function clearCanvas(context = ctx) {
		context.clearRect(0, 0, canvas.width, canvas.height);
	}
	function displayLeaderboard(context = ctx) {
		context.strokeStyle = "white";
		context.fillStyle = "white";
		context.fillRect(canvas.width - 100, 0, 100, (blobs.length * 20) + 40);
		context.fillStyle = "black";
		context.font = "14px K2D";
		context.fillText("Leaderboard", canvas.width - 90, 15);
		context.rect(canvas.width - 100, 20, 100, .1);
		const sortedblobs = blobs.slice(0, 10).sort((a,b) => b.br > a.br);
		context.font = "12px Cairo";
		context.fillStyle = "black";
		for(let i = 0; i < sortedblobs.length; ++i) {
			context.fillText(sortedblobs[i].owner.substr(0, 12), canvas.width - 90, 22 + (12 * (i + 1)));
			context.fillText(sortedblobs[i].br + " BR", canvas.width - 40, 22 + (12 * (i + 1)));
		}
		context.stroke();
	}
	// not yet
	function displayWalls() {
		for (const wall of objects.walls) {
			wall.display();
		}
	}
	function displayCooldown(context = ctx) {
		context.beginPath();
		context.strokeRect(canvas.width - 100, (blobs.length * 20) + 60, 100, 25);
		context.fillStyle = "white";
		const nomReady = Date.now() - ownBlob.lastnom > 1500;
		context.fillText(!nomReady ? `${((1500 - (Date.now() - ownBlob.lastnom)) / 1000).toFixed(0)}s` : "ready", nomReady ? canvas.width - 70 : canvas.width - 60, (blobs.length * 20) + 60 + 16);
		if (objects.images.blobnom._ready) {
			context.drawImage(objects.images.blobnom, canvas.width - 95, (blobs.length * 20) + 63, 20, 20);
		}
		context.stroke();
	}
	function displayPlayerStats(context = ctx) {
		context.font = "15px Cairo";
		context.fillText(`X: ${Math.floor(ownBlob.x)} | Y: ${Math.floor(ownBlob.y)}`, canvas.width - 90, canvas.height - 20);
		context.fillText(`BR: ${ownBlob.br}`, canvas.width - 90, canvas.height - 40);
	}
	function drawBorder(context = ctx) {
		const diffXPos = ownBlob.x + (canvas.width / 2);
		const diffXNeg = ownBlob.x - (canvas.width / 2);
		const diffYPos = ownBlob.y + (canvas.height / 2);
		const diffYNeg = ownBlob.y - (canvas.height / 2);
		if (diffXPos > mapSize.width) {
			context.beginPath();
			context.moveTo((canvas.width - (diffXPos - mapSize.width)) * scale, (diffYNeg < 0 ? -(diffYNeg + 35) : 0) * scale);
			context.lineTo((canvas.width - (diffXPos - mapSize.width)) * scale, (diffYPos > mapSize.height ? canvas.height - (diffYPos - mapSize.height) : canvas.height) * scale);
			context.stroke();
		}
		if (diffXNeg < 0) {
			context.beginPath();
			context.moveTo((-(diffXNeg + 35)) * scale, (diffYNeg < 0 ? -(diffYNeg + 35) : 0) * scale);
			context.lineTo((-(diffXNeg + 35)) * scale, (diffYPos > mapSize.height ? canvas.height - (diffYPos - mapSize.height) : canvas.height) * scale);
			context.stroke();
		}
		if (diffYPos > mapSize.height) {
			context.beginPath();
			context.moveTo((diffXNeg < 0 ? -(diffXNeg + 35) : 0) * scale, (canvas.height - (diffYPos - mapSize.height)) * scale);
			context.lineTo((diffXPos > mapSize.width ? canvas.width - (diffXPos - mapSize.width) : canvas.width) * scale, (canvas.height - (diffYPos - mapSize.height)) * scale);
			context.stroke();
		}
		if (diffYNeg < 0) {
			context.beginPath();
			context.moveTo((diffXNeg < 0 ? -(diffXNeg + 35) : 0) * scale, (-(diffYNeg + 35)) * scale);
			context.lineTo((diffXPos > mapSize.width ? canvas.width - (diffXPos - mapSize.width) : canvas.width) * scale, (-(diffYNeg + 35)) * scale);
			context.stroke();
		}
	}
	
	
	// Coordinate updates
	setInterval(() => {
		if (ownBlob.ready === false) return;
		if (ownBlob.x <= 1 && ownBlob.direction === 3) return displayUI();
		else if (ownBlob.y <= 1 && ownBlob.direction === 0) return displayUI();
		else if (ownBlob.y >= mapSize.height && ownBlob.direction === 2) return displayUI();
		else if (ownBlob.x >= mapSize.width && ownBlob.direction === 1) return displayUI();
		
		if (ownBlob.direction === 0) ownBlob.y -= 1.5;
		else if (ownBlob.direction === 1) ownBlob.x += 1.5;
		else if (ownBlob.direction === 2) ownBlob.y += 1.5;
		else if (ownBlob.direction === 3) ownBlob.x -= 1.5;
		displayUI();
		socket.emit("ffaCoordinateChange", ownBlob);
	}, 1);
	
	socket.on("ffaPlayerNommed", eventd => {
		blobs[blobs.findIndex(v => v.owner === eventd.loser.owner)].br = eventd.loser.br;
		blobs[blobs.findIndex(v => v.owner === eventd.winner.owner)].br = eventd.winner.br;
		if (eventd.loser.owner === ownBlob.owner) {
			ownBlob.x = eventd.loser.x;
			ownBlob.y = eventd.loser.y;
		}
	});
</script>
</html>
